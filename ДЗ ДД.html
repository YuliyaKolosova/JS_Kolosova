<html>
 <head>
   <script>
       `use strict`;
       /* Даны две числовые квадратные матрицы S(M, M) и T(N, N), (M,N - четные).
 Расположить элементы на побочных диагоналях в порядке убывания (в направлении сверху вниз), то есть получить матрицы SS и ТТ.
 Получить результирующие матрицы:
  S1 умножением элементов каждой строки матрицы SS на наибольший элемент соответствующей строки матрицы S 
  и Т1 суммированием элементов каждой строки матрицы ТТ с наименьшим элементом соответствующего столбца матрицы Т.
 Напечатать матрицы S1, T1. */
       let M = +prompt(`Введите четные "M" - количество элементов матрицы `);
       let N = +prompt(`Введите четные "N" - количество элементов матрицы `);
       if (M%2 != 0 && N%2 ==0){
            alert(`Введено нечетно число "M"`);
            }
            else if (M%2 == 0 && N%2 != 0){
            alert(`Введено нечетно число "N"`);
            }
            else if (M%2 != 0 && N%2 != 0){
            alert(`Введены нечетные числа "M" и "N" `);
            } else {
       let S = []; 
       let T = []; 
       let SS = []; 
       let TT = []; 
       let S1 = []; 
       let T1 = []; 
       let p; // переменная для сортировки
       let pp; // переменная для сортировки
       let k = 0; // количество сортировок
       let k1 = 0; // количество сортировок
       S = [M]; // кол-во строк матрицы S
       T = [N]; // кол-во строк матрицы T

       let vvod = prompt(`Самостоятельный ввода матриц S и T - нажмите 1`);
       switch (vvod){
             case "1":
                 for (let i = 0; i < M; i++){
                 S[i] = [M]; // кол-во столбцов матрицы S
                 for (let j = 0; j < M; j++){ 
                        S[i][j] = +prompt (`элемент матрицы S равен`);
                 };
                };

                for (let i = 0; i < N; i++){
                 T[i] = [N]; // кол-во столбцов матрицы T
                 for (let j = 0; j < N; j++){ 
                        T[i][j] = +prompt (`элемент матрицы T равен`);   
                    };
                };            
               break;
               default:
               for (let i = 0; i < M; i++){
                 S[i] = [M]; // кол-во столбцов матрицы S
                 for (let j = 0; j < M; j++){ 
                        S[i][j] = Math.round(Math.random() * 101);
                 };
                };
            
                for (let i = 0; i < N; i++){
                 T[i] = [N]; // кол-во столбцов матрицы T
                 for (let j = 0; j < N; j++){ 
                        T[i][j] = Math.round(Math.random() * 101);
                    };
                };
            break;
        };
        document.write("матрица S " + S + "<br/>");
        document.write("матрица T " + T + "<br/>");
        let s = S.slice(); //копия, содержащая копии элементов, вырезанных из исходного массива S.
        let ns = [s]; // копия массива S
        document.write("копия матрицы S " + ns + "<br/>");
        let t = T.slice(); //копия, содержащая копии элементов, вырезанных из исходного массива T.
        let nt = [t]; // копия массива T
        document.write("копия матрицы T " + nt + "<br/>");

            for (let i = 0; i < M; i++){
            j = M - i - 1; // находим номер столбца на побочной диагонали для матрицы SS
            SS[i] = S[i][j]; // матрица из элементов побочной диагонали
            };
            
            while (k < M-1){ // блок сортировки элементов побочной диагонали в порядке убывания
                for (let i = 0; i < M; i++){
                    if (SS[i] < SS [i+1]){
                    p = SS[i];
                    SS[i] = SS[i+1];
                    SS[i+1] = p;
                    };
                };
            k++;
            };
            document.write("матрица из элементов побочной диагонали матрицы S " + SS + "<br/>");

            for (let i = 0; i < M; i++){
            let j1 = M - i - 1; // находим номер столбца на побочной диагонали для матрицы S
            S[i][j1] =  SS[i]; //Заменяем отсортированные элементы на побочной диагонали в матрице S
            };
            SS = S; // присваиваем матрице S имя SS
          
        for (let i = 0; i < N; i++){
            j = N - i - 1; // находим номер столбца на побочной диагонали для матрицы TT
            TT[i] = T[i][j]; 
        };

        while (k1 < N-1){
                for (let i = 0; i < N; i++){
                    if (TT[i] < TT [i+1]){
                    pp = TT[i];
                    TT[i] = TT[i+1];
                    TT[i+1] = pp;
                    };
                };
        k1++;
        };
        document.write("матрица из элементов побочной диагонали матрицы T " + TT + "<br/>");

            for (let i = 0; i < N; i++){
            let j1 = N - i - 1; // находим номер столбца на побочной диагонали для матрицы T
            T[i][j1] =  TT[i]; //Заменяем отсортированные элементы на побочной диагонали в матрице T
            };
            TT = T; // присваиваем матрице T имя TT
      
        document.write("матрица SS " + SS + "<br/>");
        document.write("матрица TT " + TT + "<br/>");
    
        };
     </script>
 </head>
</html>